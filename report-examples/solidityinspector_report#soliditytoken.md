# SolidityInspector Analysis Report

This report was generated by [SolidityInspector](https://github.com/seeu-inspace/solidityinspector) a tool made by [Riccardo Malatesta (@seeu)](https://riccardomalatesta.com/). The purpose of this report is to assist in the process of identifying potential security weaknesses and should not be relied upon for any other use.

## Table of Contents

- [Summary](#summary)
	- [Files analyzed](#files-analyzed)
	- [Issues found](#issues-found)
- [High Issues](#high-issues)
	- [H-01 Arbitrary `from` in `transferFrom` / `safeTransferFrom`](#H-01-arbitrary-from-in-transferfrom-safetransferfrom)
- [Medium Issues](#medium-issues)
	- [M-01 Centralization risk detected: contract has a single point of control](#M-01-centralization-risk-detected-contract-has-a-single-point-of-control)
- [Low Issues](#low-issues)
	- [L-01 Timestamp dependency: use of `block.timestamp` (or `now`)](#L-01-timestamp-dependency-use-of-blocktimestamp-or-now)
- [Non-Critical Issues](#non-critical-issues)
	- [NC-01 `require()`/`revert()` statements should have descriptive reason strings](#NC-01-requirerevert-statements-should-have-descriptive-reason-strings)
	- [NC-02 Unnamed return parameters](#NC-02-unnamed-return-parameters)
	- [NC-03 Magic Numbers in contract](#NC-03-magic-numbers-in-contract)
	- [NC-04 `public` function not used internally could be marked as `external`](#NC-04-public-function-not-used-internally-could-be-marked-as-external)
- [Gas Issues](#gas-issues)
	- [G-01 Using bools for storage incurs overhead](#G-01-using-bools-for-storage-incurs-overhead)
	- [G-02 Long `revert`/`require` string](#G-02-long-revertrequire-string)
	- [G-03 Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead](#G-03-usage-of-uintsints-smaller-than-32-bytes-256-bits-incurs-overhead)

## Summary

### Files analyzed

| Filepath |
| --- |
| contracts/contracts/Faucet.sol |
| contracts/contracts/SolidityToken.sol |

### Issues found

| Category | Number of issues found |
| --- | --- |
| High Issues | 1 |
| Medium Issues | 1 |
| Low Issues | 1 |
| Non-Critical Issues | 4 |
| Gas Issues | 3 |

## High Issues

| ID | Issues | Contexts | Instances |
|----|--------|----------|-----------|
| [H-01](#H-01-arbitrary-from-in-transferfrom-safetransferfrom) | Arbitrary `from` in `transferFrom` / `safeTransferFrom` | 1 | 1 |

### [H-01] Arbitrary `from` in `transferFrom` / `safeTransferFrom`

Allowing any `from` address to be passed to `transferFrom` (or `safeTransferFrom`) may result in potential loss of funds, as it enables anyone to transfer tokens from the designated address upon approval.

#### Instances (1)

```JavaScript
contracts/contracts/SolidityToken.sol
::75 => 	function transferFrom(address _from, address _to, uint256 _value) public returns(bool success){
```


## Medium Issues

| ID | Issues | Contexts | Instances |
|----|--------|----------|-----------|
| [M-01](#M-01-centralization-risk-detected-contract-has-a-single-point-of-control) | Centralization risk detected: contract has a single point of control | 2 | 7 |

### [M-01] Centralization risk detected: contract has a single point of control

Centralization risks are weaknesses that malevolent project creators as well as hostile outside attackers can take advantage of. They may be used in several forms of attacks, including rug pulls. When contracts have a single point of control, contract owners need to be trusted to prevent fraudulent upgrades and money draining since they have privileged access to carry out administrative chores. Some solutions to this issue include implementing timelocks and/or multi signature custody. Reference: [Trusting a Smart Contract Means Trusting Its Owners: Understanding Centralization Risk](https://arxiv.org/html/2312.06510v1), [UK Court Ordered Oasis to Exploit Own Security Flaw to Recover 120k wETH Stolen in Wormhole Hack](https://medium.com/@observer1/uk-court-ordered-oasis-to-exploit-own-security-flaw-to-recover-120k-weth-stolen-in-wormhole-hack-fcadc439ca9d).

#### Instances (7)

```JavaScript
contracts/contracts/Faucet.sol
::13 => contract Owned {
::28 => contract Mortal is Owned {
::82 =>     function withdraw() external payable onlyOwner {
::88 =>     function setWithdrawalAmount(uint256 amount) public payable onlyOwner {
::92 =>     function setLockTime(uint256 amount) public payable onlyOwner {
contracts/contracts/SolidityToken.sol
::7 => contract Owned {
::22 => contract Mortal is Owned {
```


## Low Issues

| ID | Issues | Contexts | Instances |
|----|--------|----------|-----------|
| [L-01](#L-01-timestamp-dependency-use-of-blocktimestamp-or-now) | Timestamp dependency: use of `block.timestamp` (or `now`) | 1 | 2 |

### [L-01] Timestamp dependency: use of `block.timestamp` (or `now`)

The timestamp of a block is provided by the miner who mined the block. As a result, the timestamp is not guaranteed to be accurate or to be the same across different nodes in the network. In particular, an attacker can potentially mine a block with a timestamp that is favorable to them, known as "selective packing". For example, an attacker could mine a block with a timestamp that is slightly in the future, allowing them to bypass a time-based restriction in a smart contract that relies on `block.timestamp`. This could potentially allow the attacker to execute a malicious action that would otherwise be blocked by the restriction. It is reccomended to, instead, use an alternative timestamp source, such as an oracle, that is not susceptible to manipulation by a miner. References: [Timestamp dependence | Solidity Best Practices for Smart Contract Security](https://consensys.net/blog/developers/solidity-best-practices-for-smart-contract-security/), [What Is Timestamp Dependence?](https://halborn.com/what-is-timestamp-dependence/).

#### Instances (2)

```JavaScript
contracts/contracts/Faucet.sol
::73 =>             block.timestamp >= nextAccessTime[msg.sender],
::77 =>         nextAccessTime[msg.sender] = block.timestamp + lockTime;
```


## Non-Critical Issues

| ID | Issues | Contexts | Instances |
|----|--------|----------|-----------|
| [NC-01](#NC-01-requirerevert-statements-should-have-descriptive-reason-strings) | `require()`/`revert()` statements should have descriptive reason strings | 2 | 9 |
| [NC-02](#NC-02-unnamed-return-parameters) | Unnamed return parameters | 2 | 14 |
| [NC-03](#NC-03-magic-numbers-in-contract) | Magic Numbers in contract | 1 | 4 |
| [NC-04](#NC-04-public-function-not-used-internally-could-be-marked-as-external) | `public` function not used internally could be marked as `external` | 2 | 14 |

### [NC-01] `require()`/`revert()` statements should have descriptive reason strings

To increase overall code clarity and aid in debugging whenever a need is not met, think about adding precise, informative error messages to all `require` and `revert` statements. References: [Error handling: Assert, Require, Revert and Exceptions](https://docs.soliditylang.org/en/v0.8.17/control-structures.html#error-handling-assert-require-revert-and-exceptions), [Missing error messages in require statements | Opyn Bull Strategy Contracts Audit](https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit/#missing-error-messages-in-require-statements).

#### Instances (9)

```JavaScript
contracts/contracts/Faucet.sol
::68 =>         require(
::72 =>         require(
contracts/contracts/SolidityToken.sol
::93 => 				revert(0, 0)
::97 => 		require(_balanceOf[_from] >= _value);
::98 => 		require(_balanceOf[_to] + _value >= _balanceOf[_to]);
::105 => 		require(_balanceOf[_from] + _balanceOf[_to] == previousBalances);
::113 => 				revert(0, 0)
::116 => 				revert(0, 0)
::126 => 		require(_allowance[_from][msg.sender] >= _value);
```

### [NC-02] Unnamed return parameters

To increase explicitness and readability, take into account introducing and utilizing named return parameters. Reference: [Unnamed return parameters | Opyn Bull Strategy Contracts Audit](https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit/#unnamed-return-parameters).

#### Instances (14)

```JavaScript
contracts/contracts/Faucet.sol
::8 =>     function transfer(address to, uint256 amount) external returns (bool);
::9 =>     function balanceOf(address account) external view returns (uint256);
::55 =>     function getBalance() external view returns (uint256) {
::59 =>     function getwithdrawalAmount() external view returns (uint256){
::63 =>     function getLockTime() external view returns (uint256){
contracts/contracts/SolidityToken.sol
::50 => 	function name() public pure returns (string memory){
::54 => 	function symbol() public pure returns (string memory){
::58 => 	function decimals() public pure returns (uint8){
::62 => 	function balanceOf(address _owner) public view returns (uint256){
::66 => 	function totalSupply() public view returns (uint256){
::70 => 	function transfer(address _to, uint256 _value) public returns (bool success) {
::75 => 	function transferFrom(address _from, address _to, uint256 _value) public returns(bool success){
::80 => 	function approve(address _spender, uint256 _value) public returns (bool success) {
::85 => 	function allowance(address _owner, address _spender) public view returns (uint256 remaining){
```

### [NC-03] Magic Numbers in contract

Magic numbers, undefined numeric literals embedded directly into the code, pose a risk to the readability, maintainability, and security of Solidity smart contracts. To mitigate this issue, establish clear constants or variables for numeric values, providing meaningful context and promoting code transparency. Reference: [Magic numbers are used | Forta Protocol Audit](https://blog.openzeppelin.com/forta-protocol-audit#magic-numbers-are-used).

#### Instances (4)

```JavaScript
contracts/contracts/Faucet.sol
::56 =>         return token.balanceOf(address(this)) / (10**18);
::60 =>         return withdrawalAmount / (10**18);
::64 =>         return lockTime / 60;
::89 =>         withdrawalAmount = amount * (10**18);
```

### [NC-04] `public` function not used internally could be marked as `external`

`public` functions in a smart contract that aren't actually used within the contract itself could be marked as `external` as they serve no purpose internally.

#### Instances (14)

```JavaScript
contracts/contracts/Faucet.sol
::29 => 	function kill() public payable onlyOwner{
::67 =>     function requestTokens() public {
::88 =>     function setWithdrawalAmount(uint256 amount) public payable onlyOwner {
::92 =>     function setLockTime(uint256 amount) public payable onlyOwner {
contracts/contracts/SolidityToken.sol
::23 => 	function kill() public payable onlyOwner{
::50 => 	function name() public pure returns (string memory){
::54 => 	function symbol() public pure returns (string memory){
::58 => 	function decimals() public pure returns (uint8){
::62 => 	function balanceOf(address _owner) public view returns (uint256){
::66 => 	function totalSupply() public view returns (uint256){
::70 => 	function transfer(address _to, uint256 _value) public returns (bool success) {
::75 => 	function transferFrom(address _from, address _to, uint256 _value) public returns(bool success){
::80 => 	function approve(address _spender, uint256 _value) public returns (bool success) {
::85 => 	function allowance(address _owner, address _spender) public view returns (uint256 remaining){
```


## Gas Issues

| ID | Issues | Contexts | Instances | Gas Saved |
|----|--------|----------|-----------|-----------|
| [G-01](#G-01-using-bools-for-storage-incurs-overhead) | Using bools for storage incurs overhead | 1 | 2 | ~34200 | 
| [G-02](#G-02-long-revertrequire-string) | Long `revert`/`require` string | 1 | 1 | - | 
| [G-03](#G-03-usage-of-uintsints-smaller-than-32-bytes-256-bits-incurs-overhead) | Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead | 1 | 1 | - | 

### [G-01] Using bools for storage incurs overhead

Use uint256 for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from ‘false’ to ‘true’, after having been ‘true’ in the past. This can save 17100 gas per instance. Reference: [OpenZeppelin Contracts](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27).

#### Instances (2)

```JavaScript
contracts/contracts/Faucet.sol
::78 =>         bool success = token.transfer(msg.sender, withdrawalAmount);
::84 =>         bool success = token.transfer(msg.sender, token.balanceOf(address(this)));
```

### [G-02] Long `revert`/`require` string

Strings in `require()` / `revert()` longer than 32 bytes cost extra gas. Reference: [require() revert() Strings Longer Than 32 Bytes Cost Extra Gas](https://code4rena.com/reports/2022-12-caviar#g-03-requirerevert-strings-longer-than-32-bytes-cost-extra-gas).

#### Instances (1)

```JavaScript
contracts/contracts/Faucet.sol
::74 =>             "Insufficient time elapsed since last withdrawal"
```

### [G-03] Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead

Gas consumption can be greater if you use items that are less than 32 bytes in size. This is such that the EVM can only handle 32 bytes at once. In order to increase the element's size from 32 bytes to the necessary amount, the EVM must do extra operations if it is lower than that. When necessary, it is advised to utilize a bigger size and then downcast. References: [Layout of State Variables in Storage | Solidity docs](https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html#layout-of-state-variables-in-storage), [GAS OPTIMIZATIONS ISSUES by Gokberk Gulgun](https://hackmd.io/@W1m6lTsFT5WAy9C_lRTX_g/rkr5Laoys).

#### Instances (1)

```JavaScript
contracts/contracts/SolidityToken.sol
::34 => 	uint8 private constant _decimals = 18;
```


